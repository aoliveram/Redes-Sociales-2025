# Read in the data:
#nodes2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
nodes2 <- read.csv("Data files/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("Data files/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
# Examine the data:
head(nodes2)
head(links2)
# Read in the data:
#nodes <- read.csv("https://kateto.net/workshops/data/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
#links <- read.csv("https://kateto.net/workshops/data/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
nodes <- read.csv("Data files/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("Data files/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
# Read in the data:
#nodes <- read.csv("https://kateto.net/workshops/data/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
#links <- read.csv("https://kateto.net/workshops/data/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
nodes <- read.csv("Data files/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("Data files/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)
# Examine the data:
head(nodes)
head(links)
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
library('igraph')
head(links)
# Examine the data:
head(nodes)
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
# Examine the resulting object:
class(net)
net
# We can access the nodes, edges, and their attributes:
E(net)
V(net)
E(net)$type
V(net)$media
V(net)
# Or find specific nodes and edges by attribute:
# (that returns objects of type vertex sequence / edge sequence)
V(net)[media=="BBC"]
E(net)[type=="mention"]
# If you need them, you can extract an edge list
# or a matrix back from the igraph networks.
as_edgelist(net, names=T)
as_adjacency_matrix(net, attr="weight")  # ~ nodes
# We can access the nodes, edges, and their attributes:
E(net)
V(net)
E(net)$type
V(net)$media
net
head(links)
as_adjacency_matrix(net, attr="weight")  # ~ nodes
# Or data frames describing nodes and edges:
as_data_frame(net, what="edges")
as_data_frame(net, what="vertices")
# If you need them, you can extract an edge list
# or a matrix back from the igraph networks.
as_edgelist(net, names=T)                # ~ links
# If you need them, you can extract an edge list
# or a matrix back from the igraph networks.
class(as_edgelist(net, names=T))                # ~ links
class(as_adjacency_matrix(net, attr="weight"))  # ~ nodes
# Or data frames describing nodes and edges:
class(as_data_frame(net, what="edges"))
# You can also look at the network matrix directly:
net[1,]
net[5,7]
# Removing loops from the graph:
net <- simplify(net, remove.multiple = F, remove.loops = T)
# Read in the data:
#nodes2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
#links2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
nodes2 <- read.csv("Data files/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("Data files/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
# Examine the data:
head(nodes2)
head(links2)
# Examine the data:
head(nodes2)
head(links2)
# links2 is a matrix for a two-mode network:
links2 <- as.matrix(links2)
dim(links2)
dim(nodes2)
links2
# Create an igraph network object from the two-mode matrix:
net2 <- graph_from_incidence_matrix(links2)
# A built-in vertex attribute 'type' shows which mode vertices belong to.
table(V(net2)$type)
# Plot with curved edges (edge.curved=.1) and reduce arrow size:
plot(net, edge.arrow.size=.4, edge.curved=.1)
# Set node color to orange and the border color to hex #555555
# Replace the vertex label with the node names stored in "media"
plot(net, edge.arrow.size=.2, edge.curved=0,
vertex.color="orange", vertex.frame.color="#555555",
vertex.label=V(net)$media, vertex.label.color="black",
vertex.label.cex=.7)
# Generate colors based on media type:
colrs <- c("gray50", "tomato", "gold")
V(net)$media.type
V(net)$color <- colrs[V(net)$media.type]
# Compute node degrees (#links) and use that to set node size:
deg <- degree(net, mode="all")
V(net)$size <- deg*3
# Alternatively, we can set node size based on audience size:
V(net)$size <- V(net)$audience.size*0.7
# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label.color <- "black"
V(net)$label <- NA
# Set edge width based on weight:
E(net)$width <- E(net)$weight/6
#change arrow size and edge color:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
# We can even set the network layout:
graph_attr(net, "layout") <- layout_with_lgl
plot(net)
plot(net)
plot(net)
plot(net)
plot(net)
plot(net)
plot(net)
plot(net)
V(net2)$type
# Set node color to orange and the border color to hex #555555
# Replace the vertex label with the node names stored in "media"
plot(net, edge.arrow.size=.2, edge.curved=0,
vertex.color="orange", vertex.frame.color="#555555",
vertex.label=V(net)$media, vertex.label.color="black",
vertex.label.cex=.7)
# Set node color to orange and the border color to hex #555555
# Replace the vertex label with the node names stored in "media"
plot(net, edge.arrow.size=.2, edge.curved=0,
vertex.color="orange", vertex.frame.color="#555555",
vertex.label=V(net)$media, vertex.label.color="black",
vertex.label.cex=.7)
library('igraph')
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
# First attempt to plot the graph:
plot(net) # not pretty!
# Removing loops from the graph:
net <- simplify(net, remove.multiple = F, remove.loops = T)
# Let's and reduce the arrow size and remove the labels:
plot(net, edge.arrow.size=.4, vertex.label=NA)
# Plot with curved edges (edge.curved=.1) and reduce arrow size:
plot(net, edge.arrow.size=.4, edge.curved=.1)
# Set node color to orange and the border color to hex #555555
# Replace the vertex label with the node names stored in "media"
plot(net, edge.arrow.size=.2, edge.curved=0,
vertex.color="orange", vertex.frame.color="#555555",
vertex.label=V(net)$media, vertex.label.color="black",
vertex.label.cex=.7)
# Generate colors based on media type:
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]
# Compute node degrees (#links) and use that to set node size:
deg <- degree(net, mode="all")
V(net)$size <- deg*3
# Alternatively, we can set node size based on audience size:
V(net)$size <- V(net)$audience.size*0.7
# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label.color <- "black"
V(net)$label <- NA
# Set edge width based on weight:
E(net)$width <- E(net)$weight/6
#change arrow size and edge color:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
# We can even set the network layout:
graph_attr(net, "layout") <- layout_with_lgl
plot(net)
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
# Removing loops from the graph:
net <- simplify(net, remove.multiple = F, remove.loops = T)
# Let's and reduce the arrow size and remove the labels:
plot(net, edge.arrow.size=.4, vertex.label=NA)
# Plot with curved edges (edge.curved=.1) and reduce arrow size:
plot(net, edge.arrow.size=.4, edge.curved=.1)
# Set node color to orange and the border color to hex #555555
# Replace the vertex label with the node names stored in "media"
plot(net, edge.arrow.size=.2, edge.curved=0,
vertex.color="orange", vertex.frame.color="#555555",
vertex.label=V(net)$media, vertex.label.color="black",
vertex.label.cex=.7)
# Generate colors based on media type:
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]
# Compute node degrees (#links) and use that to set node size:
deg <- degree(net, mode="all")
V(net)$size <- deg*3
# Alternatively, we can set node size based on audience size:
V(net)$size <- V(net)$audience.size*0.7
# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label.color <- "black"
V(net)$label <- NA
# Set edge width based on weight:
E(net)$width <- E(net)$weight/6
#change arrow size and edge color:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
plot(net)
# We can also add a legend explaining the meaning of the colors we used:
plot(net)
legend(x="bottomleft", c("Newspaper","Television", "Online News"), pch=21,
col="#777777", pt.bg=colrs, pt.cex=2.5, bty="n", ncol=1)
ends(net, es=E(net), names=F)
# Let's color the edges of the graph based on their source node color.
# We'll get the starting node for each edge with "ends()".
edge.start <- ends(net, es=E(net), names=F)[,1]
V(net)$color[edge.start]
edge.col <- V(net)$color[edge.start]
V(net)$color
plot(net, edge.color=edge.col, edge.curved=.1)
net.bg <- sample_pa(100, 1.2)
V(net.bg)$size <- 8
V(net.bg)$frame.color <- "white"
V(net.bg)$color <- "orange"
V(net.bg)$label <- ""
E(net.bg)$arrow.mode <- 0
plot(net.bg)
# You can set the layout in the plot function:
plot(net.bg, layout=layout_randomly)
# Or calculate the vertex coordinates in advance:
l <- layout_in_circle(net.bg)
l
plot(net.bg, layout=l)
# l is simply a matrix of x,y coordinates (N x 2) for the N nodes in the graph.
# For 3D layouts, it is matrix of x, y, and z coordinates (N x 3)
# You can generate your own:
l
l <- cbind(1:vcount(net.bg), c(1, vcount(net.bg):2))
# l is simply a matrix of x,y coordinates (N x 2) for the N nodes in the graph.
# For 3D layouts, it is matrix of x, y, and z coordinates (N x 3)
# You can generate your own:
l
vcount(net.bg):2
vcount(net.bg)
l <- cbind(1:vcount(net.bg), c(1, vcount(net.bg):2))
plot(net.bg, layout=l)
# 3D sphere layout
l <- layout_on_sphere(net.bg)
plot(net.bg, layout=l)
# With force-directed layouts, you can use the 'niter' parameter to control
# the number of iterations to perform. The default is 500, but you can lower
# it for large graphs to get results faster and check if they look reasonable.
l <- layout_with_fr(net.bg, niter=50)
plot(net.bg, layout=l)
?layout_with_fr
rep(100, ecount(net.bg)-1)
c(1, rep(100, ecount(net.bg)-1))
# The layout can also use edge weights. It checks for a 'weight' edge attribute
# in the network object, or you can use a 'weights' parameter in the function.
# Nodes connected by more heavily weighted edges are pulled closer together.
ws  <-  c(1, rep(100, ecount(net.bg)-1))
lw <- layout_with_fr(net.bg, weights=ws)
plot(net.bg, layout=lw)
# Some layouts have 3D versions that you can use with parameter 'dim=3'
l <- layout_with_fr(net.bg, dim=3)
plot(net.bg, layout=l)
# As you might expect, a 3D layout has 3 columns, for X, Y, and Z coordinates:
l
# Another popular force-directed algorithm that produces nice results for
# connected graphs is Kamada Kawai. Like Fruchterman Reingold, it attempts to
# minimize the energy in a spring system.
l <- layout_with_kk(net.bg)
plot(net.bg, layout=l)
# For instance, the charge parameter below changes node repulsion:
l1 <- layout_with_graphopt(net.bg, charge=0.02)
l2 <- layout_with_graphopt(net.bg, charge=0.00000001)
par(mfrow=c(1,2), mar=c(1,1,1,1))
plot(net.bg, layout=l1)
plot(net.bg, layout=l2)
dev.off()
# The MDS (multidimensional scaling) algorithm tries to place nodes based on some
# measure of similarity or distance between them. More similar nodes are plotted
# closer to each other. By default, the measure used is based on the shortest
# paths between nodes in the network. That can be changed with the 'dist' parameter.
plot(net.bg, layout=layout_with_mds)
# The LGL algorithm is for large connected graphs. Here you can specify a root -
# the node that will be placed in the middle of the layout.
plot(net.bg, layout=layout_with_lgl)
grep("^layout_", ls("package:igraph"), value=TRUE)
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
# Remove layouts that do not apply to our graph.
layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|tree", layouts)]
layouts
par(mfrow=c(3,3), mar=c(1,1,1,1))
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(net))
plot(net, edge.arrow.mode=0, layout=l, main=layout) }
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(net))
plot(net, edge.arrow.mode=0, layout=l, main=layout) }
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(net))
plot(net, edge.arrow.mode=0, layout=l, main=layout) }
dev.off()
par(mfrow=c(3,3), mar=c(1,1,1,1))
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(net))
plot(net, edge.arrow.mode=0, layout=l, main=layout) }
dev.off()
par(mfrow=c(5,3), mar=c(1,1,1,1))
for (layout in layouts) {
print(layout)
l <- do.call(layout, list(net))
plot(net, edge.arrow.mode=0, layout=l, main=layout) }
list(net)
layouts
v1 <- c(1, 5, 11, 33)       # Numeric vector, length 4
v2 <- c("hello","world")    # Character vector, length 2 (a vector of strings)
v3 <- c(TRUE, TRUE, FALSE)  # Logical vector, same as c(T, T, F)
v4 <- c(v1,v2,v3,"boo") 	# All elements turn into strings
# Other ways to create vectors:
v <- 1:7         # same as c(1,2,3,4,5,6,7)
v <- rep(0, 77)  # repeat zero 77 times: v is a vector of 77 zeroes
v <- rep(1:3, times=2) # Repeat 1,2,3 twice
v <- rep(1:10, each=2) # Repeat each element twice
v <- seq(10,20,2) # sequence: numbers between 10 and 20, in jumps of 2
length(v)        # check the length of the vector
v1 <- 1:5         # 1,2,3,4,5
v2 <- rep(1,5)    # 1,1,1,1,1
# Element-wise operations:
v1 + v2      # Element-wise addition
v1 + 1       # Add 1 to each element
v1 * 2       # Multiply each element by 2
v1 + c(1,7)  # This doesn't work: (1,7) is a vector of different length
# Mathematical operations:
sum(v1)      # The sum of all elements
mean(v1)     # The average of all elements
sd(v1)       # The standard deviation
cor(v1,v1*5) # Correlation between v1 and v1*5
# Logical operations:
v1 > 2       # Each element is compared to 2, returns logical vector
v1==v2       # Are corresponding elements equivalent, returns logical vector.
v1!=v2       # Are corresponding elements *not* equivalent? Same as !(v1==v2)
(v1>2) | (v2>0)   # | is the boolean OR, returns a vector.
(v1>2) & (v2>0)   # & is the boolean AND, returns a vector.
v1
v2
(v1>2) & (v2>0)   # & is the boolean AND, returns a vector.
(v1>2) | (v2>0)   # | is the boolean OR, returns a vector.
(v1>2) || (v2>0)  # || is the boolean OR, returns a single value
(v1>2) && (v2>0)  # && is the boolean AND, ditto
(v1>2) || (v2>0)  # || is the boolean OR, returns a single value
l1 <- list(boo=v1,foo=v2,moo=v3,zoo="Animals!")  # A list with four components
l2 <- list(v1,v2,v3,"Animals!")
l3 <- list()
l4 <- NULL
l1["boo"]      # Access boo: this returns a list.
l1[["boo"]]    # Access boo: this returns the numeric vector
l1[[1]]        # Returns the first component of the list, equivalent to above.
l1$boo         # Named elements can be accessed using the $ operator - equivalent to [[]]
# Add more elements to a list:
l3[1] <- 11
l3
l3 <- list()
l3[[1]] <- 11 # add an element to the empty list l3
l3
l4[[3]] <- c(22, 23) # add a vector as element 3 in the empty list l4.
l4
a <- 1
A <- 2
a
A
# Read in the data:
#nodes2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
#links2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
nodes2 <- read.csv("Data files/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("Data files/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
# Examine the data:
head(nodes2)
head(links2)
# links2 is a matrix for a two-mode network:
links2 <- as.matrix(links2)
dim(links2)
dim(nodes2)
# Create an igraph network object from the two-mode matrix:
net2 <- graph_from_incidence_matrix(links2)
# Load the 'igraph' library:
library("igraph")
# Create an igraph network object from the two-mode matrix:
net2 <- graph_from_incidence_matrix(links2)
V(net2)$type
net2
# Examine the data:
head(nodes2)
head(links2)
net2
dim(net2)
View(net2)
plot(net2,vertex.label=NA)
# Examine the resulting object:
class(net2)
net2
head(links2)
# Crear la proyección sobre los nodos de la primera modalidad
proyeccion1 <- bipartite_projection(net2)$proj1
# Graficar la proyección
plot(proyeccion1, vertex.label=NA)
proyeccion2 <- bipartite_projection(net2)$proj2
plot(proyeccion2, vertex.label=NA)
links2
# Examine the data:
head(nodes2)
# Examine the data:
head(nodes2)
library("igraph")
# Read in the data:
#nodes2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
#links2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
nodes2 <- read.csv("Data files/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("Data files/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
# Examine the data:
head(nodes2)
head(links2)
class(links2)
# links2 is a matrix for a two-mode network:
links2 <- as.matrix(links2) #!!
dim(links2)
dim(nodes2)
# Create an igraph network object from the two-mode matrix:
net2 <- graph_from_incidence_matrix(links2)
# A built-in vertex attribute 'type' shows which mode vertices belong to.
table(V(net2)$type)    # FALSE==mode 1 ; TRUE==mode 2
plot(net2,vertex.label=NA)
links2
links2
proyeccion1 <- bipartite_projection(net2)$proj1
plot(proyeccion1, vertex.label=NA)
proyeccion2 <- bipartite_projection(net2)$proj2
proyeccion2 <- bipartite_projection(net2)$proj2
plot(proyeccion2, vertex.label=NA)
class(proyeccion2)
library("igraph")
# Read in the data:
#nodes2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
#links2 <- read.csv("https://kateto.net/workshops/data/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
nodes2 <- read.csv("Data files/Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)
links2 <- read.csv("Data files/Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)
# Examine the data:
head(nodes2)
head(links2)
class(links2)
class(links2)
# links2 is a matrix for a two-mode network:
links2 <- as.matrix(links2) #!!
links2
class(links2)
# Create an igraph network object from the two-mode matrix:
net2 <- graph_from_incidence_matrix(links2)
class(net2)
plot(net2,vertex.label=NA)
links2
net2
# Examine the data:
head(nodes2)
dim(links2)
dim(nodes2)
dim(links2)
proyeccion1 <- bipartite_projection(net2)$proj1
plot(proyeccion1, vertex.label=NA)
proyeccion2 <- bipartite_projection(net2)$proj2
class(proyeccion2)
plot(proyeccion2, vertex.label=NA)
head(links2)
# links2 is a matrix for a two-mode network:
links2 <- as.matrix(links2) #!!
net2
proyeccion2 <- bipartite_projection(net2)$proj2
class(proyeccion2)
plot(proyeccion2, vertex.label=NA)
