ggplot2
)
nsb <- mean(c(0.195, 0.241))
tad <- mean(c(0.44, 0.482))
concentration <- c(600, 240, 96, 38.4, 15.4, 6.1, 0)
test_sample <- tibble(
OD1 = c(
0.180,
0.188,
0.228,
0.216,
0.225,
0.169,
0.210,
0.188,
0.254,
0.203,
0.245,
0.237,
0.380,
0.338
),
OD2 = c(
0.209,
0.171,
0.223,
0.226,
0.255,
0.293,
0.207,
0.224,
0.215,
0.203,
0.390,
0.312,
0.387,
0.264
)
) %>%
rowwise() %>%
mutate(
OD_mean = mean(c(OD1, OD2)),
b0 = tad,
OD = (OD_mean / tad)
) %>%
ungroup() %>%
mutate(
id = c(
"521",
"521",
"522",
"522",
"523",
"523",
"524",
"524",
"525",
"525",
"526",
"526",
"527",
"527"
),
cond = c(
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D"
)
)
test_sample
std_curve <- tibble(
std1 = c(
0.233,
0.271,
0.352,
0.352,
0.495,
0.472,
0.44
),
std2 = c(
0.478,
0.416,
0.464,
0.540,
0.595,
0.432,
0.482
)
) %>%
rowwise() %>%
mutate(
std_mean = mean(c(std1, std2)),
b0 = b0,
tad = tad,
std_b_b0 = (std_mean / tad)
)
std_curve
four_pl <- function(params, x) {
A <- params[1] # max asymptote (b0)
B <- params[2] # hill slope
C <- params[3] # inflection point (e50)
D <- params[4] # min asymptote
y_predicted <- D + (A - D) / (1 + (x / C)^B)
return(y_predicted)
}
inverse_four_pl <- function(params, y) {
A <- params[1] # Max asymptote
B <- params[2] # Hill Slope
C <- params[3] # Inflection Point
D <- params[4] # Min asymptote
# The inverse 4PL equation
x_predicted <- C * (((A - D) / (y - D)) - 1)^(1 / B)
return(x_predicted)
}
sse_4pl <- function(params, x_obs, y_obs) {
# Get the predicted y-values from our 4PL model
y_predicted <- four_pl(params, x_obs)
# Calculate the sum of the squared differences (errors)
error <- sum((y_obs - y_predicted)^2)
return(error)
}
initial_params <- c(
A = 1, # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = 0 # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = log(concentration[concentration > 0]),
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
preds <- four_pl(optimized_params, seq(6.1, 600, 0.01))
dat <- tibble(
x = concentration[concentration > 0],
y = four_pl(optimized_params, concentration[concentration > 0])
)
dat
calculated_conc <- inverse_four_pl(optimized_params, std_curve$std_b_b0)
percent_recovery <- (calculated_conc / concentration) * 100
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
percent_recovery
pacman::p_load(
tidyverse,
ggplot2
)
nsb <- mean(c(0.195, 0.241))
tad <- mean(c(0.44, 0.482))
concentration <- c(600, 240, 96, 38.4, 15.4, 6.1, 0)
test_sample <- tibble(
OD1 = c(
0.180,
0.188,
0.228,
0.216,
0.225,
0.169,
0.210,
0.188,
0.254,
0.203,
0.245,
0.237,
0.380,
0.338
),
OD2 = c(
0.209,
0.171,
0.223,
0.226,
0.255,
0.293,
0.207,
0.224,
0.215,
0.203,
0.390,
0.312,
0.387,
0.264
)
) %>%
rowwise() %>%
mutate(
OD_mean = mean(c(OD1, OD2)),
b0 = tad,
OD = (OD_mean / tad)
) %>%
ungroup() %>%
mutate(
id = c(
"521",
"521",
"522",
"522",
"523",
"523",
"524",
"524",
"525",
"525",
"526",
"526",
"527",
"527"
),
cond = c(
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D"
)
)
test_sample
std_curve <- tibble(
std1 = c(
0.233,
0.271,
0.352,
0.352,
0.495,
0.472,
0.44
),
std2 = c(
0.478,
0.416,
0.464,
0.540,
0.595,
0.432,
0.482
)
) %>%
rowwise() %>%
mutate(
std_mean = mean(c(std1, std2)),
b0 = b0,
tad = tad,
std_b_b0 = (std_mean / tad)
)
std_curve
four_pl <- function(params, x) {
A <- params[1] # max asymptote (b0)
B <- params[2] # hill slope
C <- params[3] # inflection point (e50)
D <- params[4] # min asymptote
y_predicted <- D + (A - D) / (1 + (x / C)^B)
return(y_predicted)
}
inverse_four_pl <- function(params, y) {
A <- params[1] # Max asymptote
B <- params[2] # Hill Slope
C <- params[3] # Inflection Point
D <- params[4] # Min asymptote
# The inverse 4PL equation
x_predicted <- C * (((A - D) / (y - D)) - 1)^(1 / B)
return(x_predicted)
}
sse_4pl <- function(params, x_obs, y_obs) {
# Get the predicted y-values from our 4PL model
y_predicted <- four_pl(params, x_obs)
# Calculate the sum of the squared differences (errors)
error <- sum((y_obs - y_predicted)^2)
return(error)
}
initial_params <- c(
A = 1, # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = 0 # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = log(concentration[concentration > 0]),
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
ggplot(data = std_curve, aes(x = concentration, y = std_b_b0)) +
geom_point(color = "blue", size = 3, aes(y = std_b_b0)) +
stat_function(fun = function(x) four_pl(optimized_params, log(x)), color = "red", size = 1) +
scale_x_log10(breaks = c(1, 10, 100, 1000)) + # Use a logarithmic x-axis scale
labs(
title = "Corrected 4-Parameter Logistic Curve Fit",
x = "Concentration (pg/mL) [Log Scale]",
y = "Normalized OD (B/B₀)"
) +
theme_minimal()
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
exp(sample_concentrations)
ggplot(data = std_curve, aes(x = concentration, y = std_b_b0)) +
geom_point(color = "blue", size = 3, aes(y = std_b_b0)) +
stat_function(fun = function(x) four_pl(optimized_params, (x)), color = "red", size = 1) +
scale_x_log10(breaks = c(1, 10, 100, 1000)) + # Use a logarithmic x-axis scale
labs(
title = "Corrected 4-Parameter Logistic Curve Fit",
x = "Concentration (pg/mL) [Log Scale]",
y = "Normalized OD (B/B₀)"
) +
theme_minimal()
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr
)
setwd(this.path::here())
readRDS(file = "../data/connectivity_matrix.rds")
## huge matrix, so better to load the object directly
connectvity_matrix <- readRDS(file = "../data/connectivity_matrix.rds")
# build graph object ----
graph_obj <- graph_from_adjacency_matrix(
connectivity_matrix,
mode = "directed",
weighted = TRUE
)
## area map
area_map <- dplyr::bind_rows(
tibble(bodyid = mb_neurons, area = "MB"),
tibble(bodyid = cx_neurons, area = "CX"),
tibble(bodyid = sez_neurons, area = "SEZ")
) %>%
group_by(bodyid) %>%
summarise(
area = paste(sort(unique(area)), collapse = "+")
)
gc()
## huge matrix, so better to load the object directly
connectivity_matrix <- readRDS(file = "../data/connectivity_matrix.rds")
# build graph object ----
graph_obj <- graph_from_adjacency_matrix(
connectivity_matrix,
mode = "directed",
weighted = TRUE
)
## area map
area_map <- dplyr::bind_rows(
tibble(bodyid = mb_neurons, area = "MB"),
tibble(bodyid = cx_neurons, area = "CX"),
tibble(bodyid = sez_neurons, area = "SEZ")
) %>%
group_by(bodyid) %>%
summarise(
area = paste(sort(unique(area)), collapse = "+")
)
## mushroom body
mb_neurons <- neuprint_find_neurons(
input_ROIs = "MB(R)",
output_ROIs = "MB(R)"
)
mb_rois <- c("MB(R)", "MB(L)")
mb_where <- paste0("n.`", mb_rois, "` = TRUE", collapse = " OR ")
mb_cypher_query <- paste("MATCH (n:Neuron) WHERE", mb_where, "RETURN n.bodyId AS bodyid, n.type AS type, n.instance AS instance, n.status AS status")
mb_query_result <- neuprint_fetch_custom(cypher = mb_cypher_query)
mb_neurons <- unlist(purrr::map(mb_query_result$data, 1))
## central complex
## this is a multi-area roi
central_complex_rois <- c("PB", "FB", "EB", "NO")
cx_where <- paste0("n.`", central_complex_rois, "` = TRUE", collapse = " OR ")
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr
)
setwd(this.path::here())
# get data ----
## server connection
neuprint_login(
server = "https://neuprint.janelia.org",
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Im5pY29uaWNvbHVhcnRlQGdtYWlsLmNvbSIsImxldmVsIjoibm9hdXRoIiwiaW1hZ2UtdXJsIjoiaHR0cHM6Ly9saDMuZ29vZ2xldXNlcmNvbnRlbnQuY29tL2EvQUNnOG9jTGZIWWtfbndCdjBfSUdwMWR5d1BBRVZ6LV9jRDgyRTIxMVlMZFpDajdzdEkxN1pBPXM5Ni1jP3N6PTUwP3N6PTUwIiwiZXhwIjoxOTM0OTI1NTgwfQ.R399P52aj7_d6lc6bDkNs6WuTiXf8V3PzL1X5vNYUZ0",
dataset = "hemibrain:v1.2.1"
)
## query data
## im interested in the mushroom body, central complex and subesophageal zone
## mushroom body
mb_neurons <- neuprint_find_neurons(
input_ROIs = "MB(R)",
output_ROIs = "MB(R)"
)
mb_rois <- c("MB(R)", "MB(L)")
mb_where <- paste0("n.`", mb_rois, "` = TRUE", collapse = " OR ")
mb_cypher_query <- paste("MATCH (n:Neuron) WHERE", mb_where, "RETURN n.bodyId AS bodyid, n.type AS type, n.instance AS instance, n.status AS status")
mb_query_result <- neuprint_fetch_custom(cypher = mb_cypher_query)
mb_neurons <- unlist(purrr::map(mb_query_result$data, 1))
## central complex
## this is a multi-area roi
central_complex_rois <- c("PB", "FB", "EB", "NO")
cx_where <- paste0("n.`", central_complex_rois, "` = TRUE", collapse = " OR ")
cx_cypher_query <- paste("MATCH (n:Neuron) WHERE", cx_where, "RETURN n.bodyId AS bodyid, n.type AS type, n.instance AS instance, n.status AS status")
cx_query_result <- neuprint_fetch_custom(cypher = cx_cypher_query)
cx_neurons <- unlist(purrr::map(cx_query_result$data, 1))
## subesophageal zone
sez_rois <- c("SAD", "GNG")
sez_where <- paste0("n.`", sez_rois, "` = TRUE", collapse = " OR ")
sez_cypher_query <- paste("MATCH (n:Neuron) WHERE", sez_where, "RETURN n.bodyId AS bodyid, n.type AS type, n.instance AS instance, n.status AS status")
sez_query_result <- neuprint_fetch_custom(cypher = sez_cypher_query)
sez_neurons <- unlist(purrr::map(sez_query_result$data, 1))
## neuron ids
neurons_ids <- c(
mb_neurons,
cx_neurons,
sez_neurons
)
# build graph object ----
graph_obj <- graph_from_adjacency_matrix(
connectivity_matrix,
mode = "directed",
weighted = TRUE
)
connectivity_matrix <- NULL
## area map
area_map <- dplyr::bind_rows(
tibble(bodyid = mb_neurons, area = "MB"),
tibble(bodyid = cx_neurons, area = "CX"),
tibble(bodyid = sez_neurons, area = "SEZ")
) %>%
group_by(bodyid) %>%
summarise(
area = paste(sort(unique(area)), collapse = "+")
)
## add area to graph
graph_vertices <- tibble(bodyid = as.numeric(V(graph_obj)$name))
## join area map to vertices
graph_vertices <- graph_vertices %>%
left_join(area_map, by = "bodyid")
## set area attribute
V(graph_obj)$area <- graph_vertices$area
area_colors <- c(
"MB" = "#E69F00",
"CX" = "#56B4E9",
"SEZ" = "#009E73",
"CX+MB" = "#0072B2",
"CX+SEZ" = "#D55E00",
"MB+SEZ" = "#CC79A7",
"CX+MB+SEZ" = "#F0E442"
)
transparent_colors <- sapply(area_colors, function(color) adjustcolor(color, alpha.f = 0.4))
V(graph_obj)$color <- transparent_colors[V(graph_obj)$area]
## to avoid random unconnected neurons
simplified_graph <- delete_edges(graph_obj, E(graph_obj)[weight < 2])
## remove now isolated neurons
simplified_graph <- delete_vertices(
simplified_graph,
V(simplified_graph)[degree(simplified_graph) == 0]
)
comps <- components(simplified_graph)
largest_comp_id <- which.max(comps$csize)
final_graph <- induced_subgraph(
simplified_graph,
V(simplified_graph)[comps$membership == largest_comp_id]
)
## compute layout
simplified_layout <- layout_with_fr(
final_graph,
grid = "grid",
niter = 1000
)
png("../figures/full_brain_graph.png", width = 5000, height = 5000, res = 300)
plot(
final_graph,
layout = simplified_layout,
vertex.label = NA,
vertex.size = 2,
edge.arrow.size = 0.05,
main = ""
)
legend(
"bottomleft",
legend = names(area_colors),
fill = area_colors,
bty = "n",
cex = 1.2
)
dev.off()
