scale_y_continuous(limits = c(0, 1)) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "top"
)
# Set the parameters for the simulation
num_trials <- 100
trials_per_block <- 10
num_blocks <- num_trials / trials_per_block
# Generate the probability evolution for Arm 1
prob_arm1 <- generate_prob_walk_ar1(n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 0.6,       # Positive phi creates momentum
noise_sd = 0.4)
# Generate the probability evolution for Arm 2 (independently)
prob_arm2 <- generate_prob_walk_ar1(n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 0.6,       # Positive phi creates momentum
noise_sd = 0.4)
generate_prob_walk_ar1 <- function(n_blocks, block_size, initial_prob, phi, noise_sd) {
# Calculate the total number of trials
total_trials <- n_blocks * block_size
# Pre-allocate a vector to store the probabilities for each trial
probabilities <- numeric(total_trials)
# --- 1. Initialization ---
# Transform the initial probability into the unbounded logit space.
current_logit <- log(initial_prob / (1 - initial_prob))
# Initialize the first step (delta) by drawing from the noise distribution.
current_delta <- rnorm(1, mean = 0, sd = noise_sd)
# Assign the initial probability to the first block of trials.
probabilities[1:block_size] <- initial_prob
# --- 2. Block-wise Evolution using AR(1) process for steps ---
for (b in 2:n_blocks) {
# The new step is a blend of the old step and new noise.
# delta(b) = phi * delta(b-1) + epsilon(b)
current_delta <- phi * current_delta + rnorm(1, mean = 0, sd = noise_sd)
# The new logit value is the old value plus the new, correlated step.
# l(b) = l(b-1) + delta(b)
current_logit <- current_logit + current_delta
# Transform the logit value back into the [0, 1] probability space.
current_prob <- 1 / (1 + exp(-current_logit))
# Assign this constant probability to all trials within the current block.
start_trial <- (b - 1) * block_size + 1
end_trial <- b * block_size
probabilities[start_trial:end_trial] <- current_prob
}
return(probabilities)
}
# Set the parameters for the simulation
num_trials <- 100
trials_per_block <- 10
num_blocks <- num_trials / trials_per_block
# Generate the probability evolution for Arm 1
prob_arm1 <- generate_prob_walk_ar1(n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 0.6,       # Positive phi creates momentum
noise_sd = 0.4)
# Generate the probability evolution for Arm 2 (independently)
prob_arm2 <- generate_prob_walk_ar1(n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 0.6,       # Positive phi creates momentum
noise_sd = 0.4)
# Combine the data into a data frame for plotting
plot_data <- data.frame(
Trial = 1:num_trials,
`Arm 1` = prob_arm1,
`Arm 2` = prob_arm2
) %>%
pivot_longer(cols = c(`Arm.1`, `Arm.2`), names_to = "Arm", values_to = "Probability")
# Create the plot using ggplot2
ggplot(plot_data, aes(x = Trial, y = Probability, color = Arm)) +
geom_line(linewidth = 1.2) +
labs(
title = "Simulated Reward Probabilities with Step Correlation (Momentum)",
subtitle = paste("phi =", 0.6, "creates smoother, trending changes in probability."),
y = "Expected Reward (Probability)",
x = "Trial"
) +
scale_color_manual(values = c("Arm 1" = "#0072B2", "Arm 2" = "#D55E00")) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "top"
)
# Generate the probability evolution for Arm 1
prob_arm1 <- generate_prob_walk_ar1(n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 1,       # Positive phi creates momentum
noise_sd = 0.4)
# Generate the probability evolution for Arm 2 (independently)
prob_arm2 <- generate_prob_walk_ar1(n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 1,       # Positive phi creates momentum
noise_sd = 0.4)
# Combine the data into a data frame for plotting
plot_data <- data.frame(
Trial = 1:num_trials,
`Arm 1` = prob_arm1,
`Arm 2` = prob_arm2
) %>%
pivot_longer(cols = c(`Arm.1`, `Arm.2`), names_to = "Arm", values_to = "Probability")
# Create the plot using ggplot2
ggplot(plot_data, aes(x = Trial, y = Probability, color = Arm)) +
geom_line(linewidth = 1.2) +
labs(
title = "Simulated Reward Probabilities with Step Correlation (Momentum)",
subtitle = paste("phi =", 0.6, "creates smoother, trending changes in probability."),
y = "Expected Reward (Probability)",
x = "Trial"
) +
scale_color_manual(values = c("Arm 1" = "#0072B2", "Arm 2" = "#D55E00")) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "top"
)
plot_data
# Create the plot using ggplot2
ggplot(plot_data, aes(x = Trial, y = Probability, color = Arm)) +
geom_line(linewidth = 1.2) +
labs(
title = "Simulated Reward Probabilities with Step Correlation (Momentum)",
subtitle = paste("phi =", 0.6, "creates smoother, trending changes in probability."),
y = "Expected Reward (Probability)",
x = "Trial"
) +
scale_color_manual(values = c("Arm.1" = "#0072B2", "Arm.2" = "#D55E00")) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "top"
)
# Create the plot using ggplot2
ggplot(plot_data, aes(x = Trial, y = Probability, color = Arm)) +
geom_line(linewidth = 1.2) +
scale_color_manual(values = c("Arm.1" = "#0072B2", "Arm.2" = "#D55E00")) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "none"
)
# Generate the probability evolution for Arm 1
prob_arm1 <- generate_prob_walk_ar1(
n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 0.1, # Positive phi creates momentum
noise_sd = 0.4
)
# Generate the probability evolution for Arm 2 (independently)
prob_arm2 <- generate_prob_walk_ar1(
n_blocks = num_blocks,
block_size = trials_per_block,
initial_prob = 0.5,
phi = 0.1, # Positive phi creates momentum
noise_sd = 0.4
)
# Combine the data into a data frame for plotting
plot_data <- data.frame(
Trial = 1:num_trials,
`Arm 1` = prob_arm1,
`Arm 2` = prob_arm2
) %>%
pivot_longer(cols = c(`Arm.1`, `Arm.2`), names_to = "Arm", values_to = "Probability")
# Create the plot using ggplot2
ggplot(plot_data, aes(x = Trial, y = Probability, color = Arm)) +
geom_line(linewidth = 1.2) +
scale_color_manual(values = c("Arm.1" = "#0072B2", "Arm.2" = "#D55E00")) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5),
plot.subtitle = element_text(hjust = 0.5),
legend.position = "none"
)
library(ggplot2)
library(dplyr)
dat <- tibble(
x = 1:100,
y = cumsum(rnorm(n = 100, mean = 0, sd = 1))
)
dat
dat %>%
ggplot(aes(
x, y
)) +
geom_line()
dat %>%
ggplot(aes(
x, y
)) +
geom_line() +
ylab("Difference wave") +
xlab("RPE") +
theme_minimal()
dat %>%
ggplot(aes(
x, y
)) +
geom_line() +
geom_hline(yintercept = 0, linetype = "dashed") +
ylab("Difference wave") +
xlab("RPE") +
theme_minimal()
dat %>%
ggplot(aes(
x, y
)) +
geom_line() +
geom_hline(yintercept = 0, linetype = "dashed") +
ylab("Difference wave") +
xlab("RPE") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
dat %>%
ggplot(aes(
x, y
)) +
geom_line(linewidth = 5) +
geom_hline(yintercept = 0, linetype = "dashed") +
ylab("Difference wave") +
xlab("RPE") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
dat %>%
ggplot(aes(
x, y
)) +
geom_line(linewidth = 3) +
geom_hline(yintercept = 0, linetype = "dashed") +
ylab("Difference wave") +
xlab("RPE") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
dat %>%
ggplot(aes(
x, y
)) +
geom_line(linewidth = 3) +
geom_hline(yintercept = 0, linetype = "dashed",
linewidth = 3) +
ylab("Difference wave") +
xlab("RPE") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
dat %>%
ggplot(aes(
x, y
)) +
geom_line(linewidth = 3) +
geom_hline(yintercept = 0, linetype = "dashed",
linewidth = 3) +
ylab("Time") +
xlab("RPE derivative") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
dat <- tibble(
x = 1:1000,
y = cumsum(rnorm(n = 1000, mean = 0, sd = 1))
)
dat %>%
ggplot(aes(
x, y
)) +
geom_line(linewidth = 3) +
geom_vline(xintercept = c(200, 350), linetype = "dashed",
linewidth = 2) +
ylab("Time") +
xlab("RPE derivative") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
dat %>%
ggplot(aes(
x, y
)) +
geom_line(linewidth = 3) +
geom_vline(
xintercept = c(200, 350), linetype = "dashed",
linewidth = 2
) +
ylab("RPE derivative") +
xlab("Time") +
theme_minimal() +
theme(
text = element_text(size = 30)
)
?geom_hline
?tidymodels
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
install.packages("ergm")
options(repos = getOption("repos")["CRAN"])
install.packages("ergm")
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
install.packages("tergm")
# libs ----
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
library(tergm)
install.packages("tergm")
# libs ----
options(repos = getOption("repos")["CRAN"])
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
install.packages("ergm")
library(ergm)
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet
)
install.packages("statnet")
library(statnet)
remove.packages("tergm")
install.packages("tergm", dependencies = TRUE)
update.packages()
update.packages(tidyverse)
update.packages("tidyverse")
pacman::p_load(
tidyverse,
ggplot2,
ggthemes,
ggokabeito,
igraph,
neuprintr,
future.apply,
statnet,
intergraph,
texreg,
btergm
)
setwd(this.path::here())
fit_cx <- read_rds(file = "fit_cx.rds")
fit_mb <- read_rds(file = "fit_mb.rds")
fit_sez <- read_rds(file = "fit_sez.rds")
# multivariate parameter comparison
compare_vectors <- function(coef1, se1, coef2, se2) {
diff <- coef1 - coef2
cov_matrix <- diag(se1^2 + se2^2)
chi2_stat <- t(diff) %*% solve(cov_matrix) %*% diff
df <- length(coef1)
p_value <- pchisq(as.numeric(chi2_stat),
df = df,
lower.tail = FALSE
)
list(
chi2 = as.numeric(chi2_stat),
df = df,
p.value = p_value
)
}
cx_est
cx_est <- unname(c(coef(fit_cx), summary(fit_cx)$coefficients[, "Std. Error"]))
cx_est
mb_est <- unname(c(coef(fit_mb), summary(fit_mb)$coefficients[, "Std. Error"]))
mb_est
sez_est <- unname(c(coef(fit_sez), summary(fit_sez)$coefficients[, "Std. Error"]))
sez_est
cx_est
coef_cx <- cx_est[c(2, 3)]
coef_cx
# standard error vectors
se_cx <- cx_est[c(5, 6)]
se_mb <- mb_est[c(5, 6)]
se_sez <- sez_est[c(5, 6)]
se_sez
se_mb
se_cx
cx_est
# cx vs sez
test_cx_sez <- compare_vectors(
coef_cx,
se_cx,
coef_sez,
se_sez
)
# coeficient vectors
coef_cx <- cx_est[c(2, 3)]
coef_mb <- mb_est[c(2, 3)]
coef_sez <- sez_est[c(2, 3)]
# standard error vectors
se_cx <- cx_est[c(5, 6)]
se_mb <- mb_est[c(5, 6)]
se_sez <- sez_est[c(5, 6)]
# cx vs sez
test_cx_sez <- compare_vectors(
coef_cx,
se_cx,
coef_sez,
se_sez
)
test_cx_sez
# cx vs mb
test_cx_mb <- compare_vectors(
coef_cx,
se_cx,
coef_mb,
se_mb
)
test_cx_mb
# mb vs sez
test_mb_sez <- compare_vectors(
coef_mb,
se_mb,
coef_sez,
se_sez
)
test_mb_sez
test_cx_sez
test_cx_mb
test_mb_sez
