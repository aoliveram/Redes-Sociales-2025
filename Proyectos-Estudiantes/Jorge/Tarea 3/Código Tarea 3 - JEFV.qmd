---
title: "Tarea 3 - Código"
format: html
editor: visual
---

```{r}
library(netdiffuseR)
library(igraph)
library(Matrix)

set.seed(1234)

## -------------------------------------------
## Parámetros globales
## -------------------------------------------
n        <- 250            # nodos
k_ws     <- 8              # grado en el anillo base (par)
p_rewire <- 0.10           # prob. de rewire WS
Tmax     <- 30             # horizonte temporal (slices)
seed_p   <- 0.05           # 5% semillas
theta    <- runif(n, min = 0.1, max = 0.5)   # U(0.1, 0.5) (mismos umbrales en ambas corridas)

## Parámetros Kobayashi (elige y compara)
LAMBDA   <- 0.20    # tolerancia a la incertidumbre (menor = más conservador)
BETA     <- 20      # incertidumbre de exposición (mayor = más precisa)

```

```{r}
# -------------------------------------------
## (A) Grafo Watts–Strogatz (estático) con netdiffuseR
##     y plot rápido con igraph
## -------------------------------------------
A <- rgraph_ws(n = n, k = k_ws, p = p_rewire, undirected = TRUE)  # matriz de adyacencia
g_ws <- graph_from_adjacency_matrix(A, mode = "undirected", diag = FALSE)

plot(g_ws,
     vertex.size = 1, vertex.label = NA,
     layout = layout_with_fr,
     main = sprintf("Watts–Strogatz: n=%d, k=%d, p=%.2f", n, k_ws, p_rewire))
plot(g_ws,
     vertex.size = 1, vertex.label = NA,
     layout = layout_in_circle(g_ws),
     main = sprintf("Watts–Strogatz: n=%d, k=%d, p=%.2f", n, k_ws, p_rewire))
```

```{r}
## -------------------------------------------
## (B) Simulación determinista con rdiffnet()
##     Usando la MISMA red A como seed.graph
##     - seed.nodes = "central" (5% mayor grado)
##     - threshold.dist = theta (vector fijo, umbral por nodo)
## -------------------------------------------
dn_det <- netdiffuseR::rdiffnet(
  seed.graph     = A,        # <- MISMO grafo WS pasado directamente
  t              = Tmax,     # recicla A a lo largo del tiempo
  seed.nodes     = "central",
  seed.p.adopt   = seed_p,
  threshold.dist = theta,    # vector de umbrales por nodo
  rewire         = FALSE,
  stop.no.diff   = FALSE,
  name           = "Determinista (Valente) / WS"
)

## Curva de adopción determinista
par(mar = c(4,4,2,1))
plot_adopters(
  dn_det,
  main = "Adopción determinista"
)
```

```{r}
## -------------------------------------------
## (B) Simulación determinista con rdiffnet()
##     1000 réplicas para obtener curva promedio
##     - seed.nodes = "central" (5% mayor grado)
##     - threshold.dist = theta (vector fijo, umbral por nodo)
## -------------------------------------------

n_sims <- 1000  # Número de simulaciones

# Matriz para almacenar adopciones acumuladas por tiempo
adoption_matrix <- matrix(0, nrow = n_sims, ncol = Tmax + 1)

# Ejecutar las simulaciones
cat("Ejecutando", n_sims, "simulaciones deterministas...\n")
pb <- txtProgressBar(min = 0, max = n_sims, style = 3)

for (i in 1:n_sims) {
  dn_det <- netdiffuseR::rdiffnet(
    seed.graph     = A,        # <- MISMO grafo WS pasado directamente
    t              = Tmax,     # recicla A a lo largo del tiempo
    seed.nodes     = "central",
    seed.p.adopt   = seed_p,
    threshold.dist = theta,    # vector de umbrales por nodo
    rewire         = FALSE,
    stop.no.diff   = FALSE,
    name           = "Determinista (Valente) / WS"
  )
  
  # Extraer número de adoptantes acumulados por tiempo
  # Usamos la matriz de adopción directamente
  adopt_times <- dn_det$toa  # Tiempo de adopción de cada nodo
  
  # Calcular adopción acumulada para cada tiempo
  cum_adopt <- numeric(Tmax + 1)
  for (t in 0:Tmax) {
    cum_adopt[t + 1] <- sum(adopt_times <= t, na.rm = TRUE) / dn_det$meta$n
  }
  
  adoption_matrix[i, ] <- cum_adopt
  
  setTxtProgressBar(pb, i)
}
close(pb)
cat("Simulaciones completadas.\n")

# Guardar la última simulación para referencia
dn_det_last <- dn_det

# Calcular promedio y desviación estándar
adoption_mean <- colMeans(adoption_matrix)
adoption_sd <- apply(adoption_matrix, 2, sd)

# Crear el gráfico con estilo plot_adopters
par(mar = c(4, 4, 3, 1))

# Calcular adopciones nuevas (no acumuladas) para cada tiempo
new_adopters <- c(adoption_mean[1], diff(adoption_mean))

# Crear el gráfico base
plot(0:Tmax, adoption_mean, 
     type = "o", 
     col = "red", 
     pch = 1,
     lwd = 2,
     ylim = c(0, 1),
     xlab = "Tiempo",
     ylab = "Proporción",
     main = sprintf("Adopción determinista", n_sims))

# Añadir línea de adopciones por periodo (triángulos)
points(0:Tmax, new_adopters, 
       type = "o", 
       col = "black",
       pch = 2,
       lty = 1)

# Añadir banda de confianza para acumulados
polygon(c(0:Tmax, rev(0:Tmax)),
        c(pmin(adoption_mean + adoption_sd, 1), 
          rev(pmax(adoption_mean - adoption_sd, 0))),
        col = rgb(1, 0, 0, 0.15), 
        border = NA)

# Añadir leyenda estilo plot_adopters
legend("topleft",
       legend = c("Adoptadores acumulados", "Adoptadores"),
       col = c("red", "black"),
       pch = c(1, 2),
       lty = 1,
       bty = "n")
```

```{r}
## -------------------------------------------
## (C) Simulación Kobayashi (fuera de rdiffnet)
## ... con medición de umbrales efectivos ...
## -------------------------------------------

# --- INICIALIZACIÓN ---
deg       <- Matrix::rowSums(A)
n_seeds   <- max(1, round(seed_p * n))
seed_ids  <- order(deg, decreasing = TRUE)[seq_len(n_seeds)]

y0 <- integer(n); y0[seed_ids] <- 1

k_vec <- pmax(Matrix::rowSums(A), 1)  # evita div/0
eps   <- 1e-8

Y_kob <- matrix(0L, n, Tmax + 1)
Y_kob[, 1] <- y0

Tgraph <- length(dn_det$graph)  
stopifnot(Tgraph == Tmax)

# --- ¡NUEVO! INICIALIZAR EL VECTOR PARA GUARDAR UMBRALES EFECTIVOS ---
umbrales_efectivos <- rep(NA_real_, n)
# Lo inicializamos con NA_real_ (números reales) para guardar los valores de exposición.

# -------------------------------------------
# --- BUCLE DE SIMULACIÓN PRINCIPAL ---
# -------------------------------------------
for (t in 1:Tmax) {
  y_t <- Y_kob[, t]
  
  # n x Tgraph (repetimos el estado...)
  cumadopt_t <- matrix(as.integer(y_t), nrow = n, ncol = Tgraph)
  
  # Cálculo de exposición real
  q_all <- as.numeric(netdiffuseR::exposure(
    graph      = dn_det$graph,
    cumadopt   = cumadopt_t,
    normalized = TRUE
  ))
  
  # Extraer la exposición del slice t
  idx_ini <- (t - 1) * n + 1
  idx_fin <- t * n
  q_t <- q_all[idx_ini:idx_fin]
  
  # -- Mecanismo de decisión de Kobayashi (sin cambios) --
  q_clip <- pmin(pmax(q_t, eps), 1 - eps)
  mtilde <- rbinom(n, size = k_vec, prob = q_clip)
  alpha  <- (q_clip * BETA) / (1 - q_clip)
  post_a <- alpha + mtilde
  post_b <- BETA  + k_vec - mtilde
  F_theta   <- pbeta(theta, shape1 = post_a, shape2 = post_b)
  adopt_now <- (F_theta < LAMBDA)
  
  # Monotonía
  y_next <- as.integer(adopt_now | (y_t == 1))
  
  # --- ¡NUEVO! REGISTRO DE UMBRALES EFECTIVOS ---
  # 1. Identificar quiénes eran no-adoptantes antes (y_t == 0)
  # 2. Y ahora son adoptantes (y_next == 1)
  nuevos_adoptantes_idx <- which(y_t == 0 & y_next == 1)
  
  # 3. Para estos nuevos adoptantes, guardar la exposición REAL (q_t) que causó su adopción.
  if (length(nuevos_adoptantes_idx) > 0) {
    # Solo asignamos el umbral efectivo la primera vez que adoptan.
    # El 'is.na' asegura que no sobrescribamos valores.
    indices_a_registrar <- nuevos_adoptantes_idx[is.na(umbrales_efectivos[nuevos_adoptantes_idx])]
    if (length(indices_a_registrar) > 0) {
      umbrales_efectivos[indices_a_registrar] <- q_t[indices_a_registrar]
    }
  }
  # ----------------------------------------------------
  
  # Actualizar el estado para el siguiente período
  Y_kob[, t + 1] <- y_next
  
  # Condición de parada
  if (all(y_next == y_t)) break
}

# -------------------------------------------
# --- EMPAQUETADO Y VISUALIZACIÓN DE RESULTADOS ---
# -------------------------------------------

## Empaquetar resultado Kobayashi en diffnet (sin cambios)
toa_kob <- rep(NA_integer_, n)
for (i in 1:n) {
  hit <- which(Y_kob[i, ] == 1L)
  if (length(hit)) toa_kob[i] <- min(hit)
}
dn_kob <- as_diffnet(A, toa = toa_kob)

## Curva de adopción Kobayashi (sin cambios)
plot_adopters(
  dn_kob,
  main = sprintf("Adopción probabilística\nλ=%.2f, β=%d", LAMBDA, BETA)
)



```

```{r}
# Extraer los umbrales efectivos de los nodos que efectivamente adoptaron (excluyendo NAs)
theta_efectivo <- umbrales_efectivos[!is.na(umbrales_efectivos)]

# Imprimir un resumen numérico para comparar
cat("\n--- Comparación de Umbrales ---\n")
cat("Distribución de Umbrales Teóricos (Originales):\n")
print(summary(theta))
cat("\nDistribución de Umbrales Efectivos (Derivados del Modelo Probabilístico):\n")
print(summary(theta_efectivo))

# Crear un gráfico de densidad comparativo
plot(density(theta), 
     col = "blue", 
     lwd = 2, 
     main = "Comparación de Distribuciones de Umbrales",
     xlab = "Valor del Umbral (θ)",
     ylab = "Densidad",
     ylim = c(0, max(density(theta)$y, density(theta_efectivo)$y) * 1.1) # Ajuste de eje Y
     )
lines(density(theta_efectivo), col = "red", lwd = 2, lty = 2)
legend("topright",
       legend = c("Determinista", "Probabilístico"),
       col = c("blue", "red"),
       lty = c(1, 2),
       lwd = 2,
       bty = "n",
       cex = 0.6,      # Aumenta el tamaño del texto
       x.intersp = 1.5, # Aumenta espacio horizontal entre símbolo y texto
       y.intersp = 1.3  # Aumenta espacio vertical entre líneas
       )
```

```{r}
## -------------------------------------------
## (C) Simulación Kobayashi - 1000 réplicas
##     para obtener curva promedio
## -------------------------------------------

n_sims_kob <- 1000  # Número de simulaciones

# Matriz para almacenar adopciones acumuladas por tiempo
adoption_matrix_kob <- matrix(0, nrow = n_sims_kob, ncol = Tmax + 1)

# Matriz para guardar umbrales efectivos de todas las simulaciones
umbrales_efectivos_todas <- matrix(NA_real_, nrow = n_sims_kob, ncol = n)

# --- INICIALIZACIÓN COMÚN ---
deg       <- Matrix::rowSums(A)
n_seeds   <- max(1, round(seed_p * n))
seed_ids  <- order(deg, decreasing = TRUE)[seq_len(n_seeds)]
k_vec <- pmax(Matrix::rowSums(A), 1)
eps   <- 1e-8
Tgraph <- length(dn_det_last$graph)
stopifnot(Tgraph == Tmax)

# Ejecutar las simulaciones
cat("Ejecutando", n_sims_kob, "simulaciones Kobayashi...\n")
pb_kob <- txtProgressBar(min = 0, max = n_sims_kob, style = 3)

for (sim in 1:n_sims_kob) {
  # Inicialización para esta simulación
  y0 <- integer(n); y0[seed_ids] <- 1
  Y_kob <- matrix(0L, n, Tmax + 1)
  Y_kob[, 1] <- y0
  umbrales_efectivos <- rep(NA_real_, n)
  
  # --- BUCLE DE SIMULACIÓN ---
  for (t in 1:Tmax) {
    y_t <- Y_kob[, t]
    
    cumadopt_t <- matrix(as.integer(y_t), nrow = n, ncol = Tgraph)
    
    # Cálculo de exposición real
    q_all <- as.numeric(netdiffuseR::exposure(
      graph      = dn_det_last$graph,
      cumadopt   = cumadopt_t,
      normalized = TRUE
    ))
    
    # Extraer la exposición del slice t
    idx_ini <- (t - 1) * n + 1
    idx_fin <- t * n
    q_t <- q_all[idx_ini:idx_fin]
    
    # Mecanismo de decisión de Kobayashi
    q_clip <- pmin(pmax(q_t, eps), 1 - eps)
    mtilde <- rbinom(n, size = k_vec, prob = q_clip)
    alpha  <- (q_clip * BETA) / (1 - q_clip)
    post_a <- alpha + mtilde
    post_b <- BETA  + k_vec - mtilde
    F_theta   <- pbeta(theta, shape1 = post_a, shape2 = post_b)
    adopt_now <- (F_theta < LAMBDA)
    
    # Monotonía
    y_next <- as.integer(adopt_now | (y_t == 1))
    
    # Registro de umbrales efectivos
    nuevos_adoptantes_idx <- which(y_t == 0 & y_next == 1)
    if (length(nuevos_adoptantes_idx) > 0) {
      indices_a_registrar <- nuevos_adoptantes_idx[is.na(umbrales_efectivos[nuevos_adoptantes_idx])]
      if (length(indices_a_registrar) > 0) {
        umbrales_efectivos[indices_a_registrar] <- q_t[indices_a_registrar]
      }
    }
    
    # Actualizar el estado
    Y_kob[, t + 1] <- y_next
    
    # Condición de parada
    if (all(y_next == y_t)) break
  }
  
  # Guardar resultados de esta simulación
  for (t in 0:Tmax) {
    adoption_matrix_kob[sim, t + 1] <- sum(Y_kob[, t + 1]) / n
  }
  umbrales_efectivos_todas[sim, ] <- umbrales_efectivos
  
  setTxtProgressBar(pb_kob, sim)
}

close(pb_kob)
cat("Simulaciones Kobayashi completadas.\n")

# Calcular promedio y desviación estándar
adoption_mean_kob <- colMeans(adoption_matrix_kob)
adoption_sd_kob <- apply(adoption_matrix_kob, 2, sd)

# Calcular promedio de umbrales efectivos (ignorando NAs)
theta_efectivo <- apply(umbrales_efectivos_todas, 2, function(x) mean(x, na.rm = TRUE))

# Crear el gráfico con estilo plot_adopters
par(mar = c(4, 4, 3, 1))

# Calcular adopciones nuevas (no acumuladas) para cada tiempo
new_adopters_kob <- c(adoption_mean_kob[1], diff(adoption_mean_kob))

# Crear el gráfico base
plot(0:Tmax, adoption_mean_kob, 
     type = "o", 
     col = "red", 
     pch = 1,
     lwd = 2,
     ylim = c(0, 1),
     xlab = "Tiempo",
     ylab = "Proporción",
     main = sprintf("Adopción probabilística\nλ=%.2f, β=%d", LAMBDA, BETA))

# Añadir línea de adopciones por periodo (triángulos)
points(0:Tmax, new_adopters_kob, 
       type = "o", 
       col = "black",
       pch = 2,
       lty = 1)

# Añadir banda de confianza para acumulados
polygon(c(0:Tmax, rev(0:Tmax)),
        c(pmin(adoption_mean_kob + adoption_sd_kob, 1), 
          rev(pmax(adoption_mean_kob - adoption_sd_kob, 0))),
        col = rgb(1, 0, 0, 0.15), 
        border = NA)

# Añadir leyenda estilo plot_adopters
legend("topleft",
       legend = c("Adoptadores acumulados", "Adoptadores"),
       col = c("red", "black"),
       pch = c(1, 2),
       lty = 1,
       bty = "n")
```

```{r}
# Extraer los umbrales efectivos de los nodos que efectivamente adoptaron (excluyendo NAs)
theta_efectivo <- umbrales_efectivos[!is.na(umbrales_efectivos)]

# Imprimir un resumen numérico para comparar
cat("\n--- Comparación de Umbrales ---\n")
cat("Distribución de Umbrales Teóricos (Originales):\n")
print(summary(theta))
cat("\nDistribución de Umbrales Efectivos (Derivados del Modelo Probabilístico):\n")
print(summary(theta_efectivo))

# Crear un gráfico de densidad comparativo
plot(density(theta), 
     col = "blue", 
     lwd = 2, 
     main = "Comparación de Distribuciones de Umbrales",
     xlab = "Valor del Umbral (θ)",
     ylab = "Densidad",
     ylim = c(0, max(density(theta)$y, density(theta_efectivo)$y) * 1.1) # Ajuste de eje Y
     )
lines(density(theta_efectivo), col = "red", lwd = 2, lty = 2)
legend("topright",
       legend = c("Determinista", "Probabilístico"),
       col = c("blue", "red"),
       lty = c(1, 2),
       lwd = 2,
       bty = "n",
       cex = 0.6,      # Aumenta el tamaño del texto
       x.intersp = 1.5, # Aumenta espacio horizontal entre símbolo y texto
       y.intersp = 1.3  # Aumenta espacio vertical entre líneas
       )
```

```{r}
## -------------------------------------------
## (D) Resumen comparativo
## -------------------------------------------
final_det <- mean(dn_det$cumadopt[, ncol(dn_det$adopt)] == 1)
final_kob <- mean(Y_kob[, ncol(Y_kob)] == 1)

cat("\n--- RESUMEN ---\n")
cat(sprintf("Determinista (rdiffnet, WS):    adopción final = %.3f\n", final_det))
cat(sprintf("Kobayashi (λ=%.2f, β=%d, WS): adopción final = %.3f\n", LAMBDA, BETA, final_kob))
```
